Rust 中的每一个引用都有其 **生命周期**（_lifetime_），也就是引用保持有效的作用域。大部分时候生命周期是隐含并可以推断的，正如大部分时候类型也是可以推断的一样。类似于当因为有多种可能类型的时候必须注明类型，也会出现引用的生命周期以一些不同方式相关联的情况，所以 Rust 需要我们使用泛型生命周期参数来注明它们的关系，这样就能确保运行时实际使用的引用绝对是有效的
借用检查器负责分配和释放内存，并确保没有引用指向已释放的内存。与借用一样，生命周期期在编译时检查，这意味着如果借用检查器认为引用无效，则程序无法编译
一个值的绑定周期就是生命周期

##### 生命周期的主要作用是避免悬垂引用，它会导致程序引用了本不该引用的数据：
可帮助借用检查器确保您永远不会有无效的引用
借用的生命周期不能长于出借方的生命周期
``` Rust 
{
    let r;                // ---------+-- 'a
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &x;           //  |       |
    }                     // -+       |x在这里被释放了·
    println!("r: {}", r); //          |
    let x = 10;  // 两者地址相同
}                         // ---------+
//会自动调用Drop Trait的drop函数来销毁该变量绑定在内存中的数据，这里特指销毁堆和栈上的数据，而字符串字面量是存放在全局内存中的，它会在程序启动到程序终止期间一直存在，不会被销毁
```

- let创建默认词法作用域，也就是它的生命周期
![[Pasted image 20231231212008.png]]
- 花括号{}
- match match匹配也会产生新的词法作用域
- if let/while let
- 循环
- 函数
- 闭包


## 显示生命周期
单引号开肉，参数名通常小写字母
生命周期标注并不会改变任何引用的实际作用域，只是用于编辑器的借用检查
**标记的生命周期只是为了取悦编译器，让编译器不要难为我们**、
``` Rust
&i32        // 一个引用
&'a i32     // 具有显式生命周期的引用
&'a mut i32 // 具有显式生命周期的可变引用
fn useless<'a>(first: &'a i32, second: &'a i32) {}
```
&i32
&'a i32
&'a mut i32
##### 函数签名中的生命周期标注
一个生命周期标注，它自身并不具有什么意义，因为生命周期的作用就是告诉编译器多个引用之间的关系；
``` Rust
fn foo<'a>(x: &'a str, y: &'a str) -> &'a str {}
// 参数的生命周期--输入生命周期
// 返回值的生命周期-- 输出生命周期
// 输出的生命周期不必长于输入的生命周期
// 禁止没有输入的情况下返回输出
```

## 省略生命周期参数

编译器可以在许多情况下推断出正确的生存期，从而省去了手动写出它们的麻烦。当生存期注释是隐式的时，我们称之为生命周期省略规则：
- 函数不返回引用
- 只有一个输入参数，这个参数的生命周期自动分配给输出
- 该函数是一个方法，将 `&self` 或 `&mut self` 作为第一个参数，self的生命周期第一个域分配给输出生命周期

- fn a(s: &str) == fn a<'a>(s: &'a str)
- fn a(b: u32, s: &str) {}. === fn a<'a>(b: u32, s: &'a str) {}
- fn a(b: &mut self, s: &str) {} == fn a<'a, 'b: 'a>(&'a mut self, s: &'b str) {}
