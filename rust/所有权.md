# 律者，所以定分止争也
忘记释放--内存泄露
重复释放--问题未知
GC问题--GC在所有指向某个对象的可访问指针都失效时自动释放改对象；但是对于何时进行释放对象的控制权全部交给了GC；可能就出现本该释放的没有释放（使用的对象指向的是文件或者网络等系统资源，不能保证释放）
### 内存管理出现了三种流派：
- **垃圾回收机制(GC)**，在程序运行时不断寻找不再使用的内存，典型代表：Java、Go
- **手动管理内存的分配和释放**, 在程序中，通过函数调用的方式来申请和释放内存，典型代表：C++
- **通过所有权来管理内存**，编译器在编译时会根据一系列规则进行检查

其中 Rust 选择了第三种，这种检查只发生在编译期，检查验证你的程序不包含内存安全的问题（悬空指针、重复释放、使用未初始化的内存）；对于程序运行期，不会有任何性能上的损失。

## 内存
栈内存的生命周期是短暂的，会随着栈的展开的过程而被自动清理。
堆内存是动态的，其分配和重新分配并不遵循某个固定的模式，所以需要使用指针进行跟踪
rust和C++一样引入来智能指针来管理堆内存。智能指针在堆上开辟内存空间，并拥有所有权通过存储于栈中的指针来管理堆内存。智能指针的RAII机制利用栈的特点，在栈元素被自动清空的时候自动调用析构函数，来释放智能指针所管理的堆内存空间

## 数据类型
#### 值类型
可以将数据都保存到同一个位置的类型（原生类型）；对于值的操作效率比较高；使用完会立即释放；执行赋值或传入函数的时候，会复制一个新的副本；
#### 引用类型
存在一个指向实际存储区的指针（将数据存在堆中，而栈中存放指向堆中数据的地址）；

但是存在vec（vector）里面可能有值类型，也有引用类型
#### 值语义
复制之后，两个数据对象拥有存储空间是独立的，互不影响；
#### 引用语义
复制之后，两个数据对象互为别名。操作其中任意一个对象，会影响另一个

值语义可以保证变量值的独立性；引用语义的赋值是按位复制，可能存在内存不安全；导致堆上的数据多了一个管理者(当其中一个把内存释放，另一个就变成悬空指针)
![[Pasted image 20231231170607.png]]

#### 复制语义与移动语义
rust是可以通过是否实现Copy trait来区分值语义和引用语义
实现了Copy trait的的类型在进行按位赋值是安全的。
移动语义就是不能进行按位的复制，只是进行了所有权的移动
Copy：
默认情况下，在将一个值保存到某个位置时总是进行值的移动(实际上是拷贝)，使得只有目标位置才拥有这个值，而原始变量将变回未初始化状态，也就是暂时不可用的状态。这是Rust的移动语义。
Rust还有Copy语义，和Move语义几乎相同，唯一的区别是Copy后，原始变量仍然可用。
前面说过，Move实际上是进行了拷贝，只不过拷贝后让原始变量变回未初始化状态了，而Copy的行为，就是保留原始变量。
但Rust默认是使用Move语义，如果想要使用Copy语义，要求要拷贝的数据类型实现
Clone：
虽然实现Copy Trait可以让原变量继续拥有自己的值，但在某些需求下，不便甚至不能去实现Copy。这时如果想要继续使用原变量，可以使用`clone()`方法手动拷贝变量的数据，同时不会让原始变量变回未初始化状态；
- Copy时，只拷贝变量本身的值，如果这个变量指向了其它数据，则不会拷贝其指向的数据
- Clone时，拷贝变量本身的值，如果这个变量指向了其它数据，则也会拷贝其指向的数据
``` Rust
let vb0 = vec!["s1".to_string()];
let v = vec![vb0]; 
println!("{:p}", &v[0][0]); // 0x21c43a20c50 
let vc = v.clone(); 
println!("{:p}", &vc[0][0]); // 0x21c43a20b70
```

## 所有权

####  可变和不可变
不可变状态不能共享，避免多线程的并发出现数据竞争
- 函数的副作用可以得到控制
- 多并发时可以安全共享
``` Rust
let x = "X";
let mut c="X";
c="c1"
```

规则：
- rust中每一个值都有一个对应的变量作为它的所有者
- 在同一时间内，值有且仅有一个所有者
- 当所有者离开作用域时，它所持有的值就会被释放
特点：
- 控制资源的释放
- 出借所有权，包括可变和不可变
- 转移所有权
``` Rust
{ // s未生命，不可用
	let s = 's' // 声明s
	// todo。可以使用s
} // 作用域结束，s不可用 自动调用drop
//进入作用域后变得有效，保持有效性直到离开作用域
```

### 所有权转移
一个值的所有权被转移给了另一个变量绑定的过程--说有权转移
在变量赋值过程中，在函数传参、函数返回数据时也会Move

``` Rust
fn main(){
	let x = Box::new(5)
	let y = x;
	println!("{:?}",x) // 报错
}
```
![[Pasted image 20231231172928.png]]

###  引用
rust 提供的一种指针语义。基于指针实现（指针使用保存的是指向内存的地址，引用某块内存的别名），使用它时需要满足编译器的各种安全检查规则。分为不可变引用和可变引用；
引用在离开作用域时，就是归还所有权的时候

``` Rust
let x = 10;
let r = &x;
 *r =10 //显示解引用
 
```
### 借用j
例如&x是x的借用，通过&完成所有者的租借。借用所有权；
引用不会造成绑定变量的变量的所有权的转移。但借用所有权让所有者会有限制：
- 不可变借用期间，不能修改资源，也不能在进行可变的借用
- 可变借用期间，不能访问资源，不能在出借所有权
规则：
- 借用生命周期不能长于出借方的生命周期（防止出现悬垂指针）
- 可变借用不能有别名，可变借用具有独占性
- 不可变借用不能再次出借为可变
![[Pasted image 20231231194952.png]]







