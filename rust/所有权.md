# 律者，所以定分止争也
忘记释放--内存泄露
重复释放--问题未知
GC问题--GC在所有指向某个对象的可访问指针都失效时自动释放改对象；但是对于何时进行释放对象的控制权全部交给了GC；可能就出现本该释放的没有释放（使用的对象指向的是文件或者网络等系统资源，不能保证释放）
### 内存管理出现了三种流派：
- **垃圾回收机制(GC)**，在程序运行时不断寻找不再使用的内存，典型代表：Java、Go
- **手动管理内存的分配和释放**, 在程序中，通过函数调用的方式来申请和释放内存，典型代表：C++
- **通过所有权来管理内存**，编译器在编译时会根据一系列规则进行检查

其中 Rust 选择了第三种，这种检查只发生在编译期，检查验证你的程序不包含内存安全的问题（悬空指针、重复释放、使用未初始化的内存）；对于程序运行期，不会有任何性能上的损失。

## 内存
栈内存的生命周期是短暂的，会随着栈的展开的过程而被自动清理。
堆内存是动态的，其分配和重新分配并不遵循某个固定的模式，所以需要使用指针进行跟踪
rust和C++一样引入来智能指针来管理堆内存。智能指针在堆上开辟内存空间，并拥有所有权通过存储于栈中的指针来管理堆内存。智能指针的RAII机制利用栈的特点，在栈元素被自动清空的时候自动调用析构函数，来释放智能指针所管理的堆内存空间

## 数据类型
#### 值类型
可以将数据都保存到同一个位置的类型（原生类型）；对于值的操作效率比较高；使用完会立即释放；执行赋值或传入函数的时候，会复制一个新的副本；
#### 引用类型
存在一个指向实际存储区的指针（将数据存在堆中，而栈中存放指向堆中数据的地址）；

但是存在vec（vector）里面可能有值类型，也有引用类型
#### 值语义
复制之后，两个数据对象拥有存储空间是独立的，互不影响；
#### 引用语义
复制之后，两个数据对象互为别名。操作其中任意一个对象，会影响另一个

值语义可以保证变量值的独立性；引用语义的赋值是按位复制，可能存在内存不安全；导致堆上的数据多了一个管理者(当其中一个把内存释放，另一个就变成悬空指针)
![[Pasted image 20231231170607.png]]

#### 复制语义与移动语义
rust是可以通过是否实现Copy trait来区分值语义和引用语义
实现了Copy trait的的类型在进行按位赋值是安全的。
移动语义就是不能进行按位的复制，只是进行了所有权的移动

## 所有权

规则：
- rust中每一个值都有一个对应的变量作为它的所有者
- 在同一时间内，值有且仅有一个所有者
- 当所有者离开作用域时，它所持有的值就会被释放
``` Rust
{ // s未生命，不可用
	let s = 's' // 声明s
	// todo。可以使用s
} // 作用域结束，s不可用 自动调用drop
//进入作用域后变得有效，保持有效性直到离开作用域
```

### 所有权转移
一个值的所有权被转移给了另一个变量绑定的过程--说有权转移
``` Rust
	fn main(){
		let x = Box::new(5)
		let y = x;
		println!("{:?}",x) // 报错
	}
```
![[Pasted image 20231231172928.png]]

