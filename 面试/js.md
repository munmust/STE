#### 闭包是什么？
有权访问另一个函数作用域的变量的函数；
内部函数和存在周围作用域的引用
一个普通的函数function，如果它可以访问外层作用域的自由变量，那么这个函数就是一个闭包；从广义上的角度来说，JavaScript中的函数都是闭包；从狭义的角度来说，JavaScript中一个函数，如果访问了外层作用域的变量，那么它是一个闭包

原因：**在JavaScript中，作用域对象是在堆中被创建的（至少表现出来的行为是这样的），所以在函数返回后它们也还是能够被访问到而不被销毁**作用域，使用变量时，如果当前作用域没有会向上父作用域进行查找；这时函数存在引用导致作用域没有销毁，

表现形式
`回调`：读取了
`返回匿名函数`：保存的仅仅是window和当前作用域
`IIFE`：保存了`全局作用域window`和`当前函数的作用域`

作用
`私有化内部变量`：例如和创建个funcation A 里面的定义一个name传出get和set方法，这时就存在闭包了，只能通过穿出的方法来控制A的的name
`延长变量生命周期`
`作为工厂模式`
`装饰器`：

问题：
`内存泄露`

#### 垃圾回收
对程序产生的不用的内存或者是之前用过了，以后不会再用的内存空间进行回收
当对象已经不存在引用时将会进行回收

js会定期的找出不在用到的内存进行清除
##### 标记清除法
分为标记和清除两个阶段
`标记`：运行的时候回给内存中所有的变量标记为 垃圾 ；然后会从各个根对象遍历，将非垃圾变量标记为 使用；
`清除`：将标记为垃圾的进行清除

问题：释放了之后，会导致内存不是连续的是碎片的，导致当需要一个大内存时存在问题；
##### 标记整理
释放之后会将使用中的内存向内存的一段进行移动，最后清楚内存边界
##### 引用计数法
当声明一个引用类型并赋值给变量时，这个值的引用次数初始为1，每有一个引用了它就会加一，变量被其他值覆盖之后就减一，当为0时说明没有引用可以进行回收；循环引用导致内存泄漏

##### 分代式内存回收
分为新生代老生代的内存
新、小、存活时间短的对象作为新生代，快速清理；提高回收效率
###### 新生代
新声代的大小比较小，
**分为使用区和空闲区**
`新加入的变量都会放到使用区里面,当使用区快写满时进行一次垃圾回收`：对使用区的活动对象进行标记，将使用区的标记对象复制到空闲区，空闲区中对需要清楚的对象进行回收；然后使用区和空闲区进行互换，空闲区变成使用区，使用区变成空闲区；以此往复；当一个对象在多次的垃圾回收中一一直存在，会复制到老生代中；如果复制一个对象到空闲区时，空闲区空间占用超过了 25%，那么这个对象会被直接晋升到老生代空间中；
`老生代`：标记整理
###### 增量标记
将一次GC分成很多的小步，每执行一部分就让给应用执行一会；交替多次完成一轮GC标记
*三色标记法*
三个颜色：当没有被检查引用是是白色的，当进行检查时会被标记为灰色，当发现被引用标记为黑色；当暂停之后，判断是否有灰色的标记又的话就继续从灰色部分开始标记；如果没有灰色了就直接开始清理；
当有黑色的标记对象引用了白色的对象，会将白色变为灰色
*惰性清理*
不会一次性全部清理，分多次清理


#### 事件循环原理
js引擎等待任务、执行任务、进入休眠状态切换的无限循环
同步任务、异步任务、宏任务、微任务；
主线程执行完执行栈中的所有任务后会去查看任务队列中是否还有任务
每来一个事件就会将这个任务进入执行栈中，如果为同步任务会直接进行执行，如果是异步任务会将其放到任务队列中，当主线程完成了没有同步任务后；只要异步任务有了运行结果，就在 **任务队列** 之中放置一个事件， 一旦 **执行栈** 中的所有同步任务执行完毕，系统就会读取 **任务队列**，看看里面有哪些待执行事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行
异步任务又分为宏任务和微任务；
同步任务->宏任务->微任务->宏任务

#### 虚拟dom是什么? 原理? 优缺点?
react中虚拟DOM其实就是一个个Fiber节点，每个Fiber节点的stateNode又对应页面上真实的DOM节点；一个个的Fiber就构成一棵Fiber树，这个Fiber树就是页面根节点开始的整个页面的内容构成的；利用虚拟DOM在通过react的虚拟DOM的Diff算法以及双缓存机制，可以避免页面中频繁出现DOM的操作，提高响应
####  react 在虚拟dom的diff上，做了哪些改进使得速度很快?
diff主要是对同级的节点进行diff，进行跨级的diff提高了di f