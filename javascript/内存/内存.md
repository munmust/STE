
JavaScript 是在创建变量（对象，字符串等）时自动进行了分配内存，并且在不使用它们时“自动”释放。释放的过程称为垃圾回收
# 内存生命周期
1. 分配你所需要的内存
2.  使用分配到的内存（读、写）
3.  不需要时将其释放/归还

## JS 环境中分配的内存生命周期：
1.  内存分配（内存由操作系统分配，允许您的程序使用它）：当我们申明变量、函数、对象的时候，系统会自动为他们分配内存
2.  内存使用（这是程序实际使用先前分配的内存的时间。当您在代码中使用分配的变量时，就会发生读取和写入操作）：即读写内存，也就是使用变量、函数等
3.  内存回收（释放不需要的全部内存的时候了，以便它可以再次释放并可用）：使用完毕，由垃圾回收机制自动回收不再使用的内存
### JavaScript 的内存分配
#### 值的初始化
JavaScript 在定义变量时就完成了内存分配
``` javascript
// 给数值变量分配内存
let number = 123;
// 给字符串分配内存
let string = "string";
// 给对象及其包含的值分配内存
let obj = {
  obj1: 1,
  obj2: 'string'
}; 
// 给数组及其包含的值分配内存（对象）
let arr = [123, "string"];
// 给函数（对象）分配内存
function fn(param){
  return param;
} 
// 函数表达式也能分配内存
someElement.addEventListener(
  'click',
  function () {
    someElement.style.backgroundColor = 'blue';
  },
  false
);
```

####  通过函数调用分配内存
函数调用结果分配对象内存
``` javascript
var date = new Date(); // 分配一个 Date 对象
var ele = document.createElement('div'); // 分配一个 DOM 元素
```
#### 分配新变量或新对象

``` javascript
var s = "azerty";
var s2 = s.substr(0, 3); // s2 是一个新的字符串
// 因为字符串是不变量，
// JavaScript 可能决定不分配内存，
// 只是存储了 [0-3] 的范围。
var a = ["ouais ouais", "nan nan"];
var a2 = ["generation", "nan nan"];
var a3 = a.concat(a2);
// 新数组有四个元素，是 a 连接 a2 的结果
```

### 内存的使用
实际上是对分配内存进行读取与写入的操作。读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数
``` javascript
let a = 123
console.log(a) // 内存的读取
```
### 内存回收

####  垃圾收集
由于无法确定某些内存是否“不再需要”，因此垃圾收集对一般问题的解决方案实施了限制

####  引用计数
垃圾回收算法主要依赖于引用的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个 Javascript 对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）

这是最初级的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收

当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是 `1`，如果这个值再被赋值给另一个变量，则引用次数加 `1`。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减 `1`。当这个引用次数变成 `0` 时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为 `0` 的值所占的内存。

```javascript 
var o = {
  a: {
    b:2
  }
};
// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量 o
// 很显然，没有一个可以被垃圾收集


var o2 = o; // o2 变量是第二个对“这个对象”的引用

o = 1;      // 现在，“这个对象”只有一个 o2 变量的引用了，“这个对象”的原始引用 o 已经没有

var oa = o2.a; // 引用“这个对象”的 a 属性
               // 现在，“这个对象”有两个引用了，一个是 o2，一个是 oa

o2 = "yo"; // 虽然最初的对象现在已经是零引用了，可以被垃圾回收了
           // 但是它的属性 a 的对象还在被 oa 引用，所以还不能回收

oa = null; // a 属性的那个对象现在也是零引用了
           // 它可以被垃圾回收了

```
无法处理循环引用的事例。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。
``` javascript
function f(){
  var o = {};
  var o2 = {};
  o.a = o2; // o 引用 o2
  o2.a = o; // o2 引用 o

  return "azerty";
}

f();

var div;
window.onload = function(){
  div = document.getElementById("myDivElement");
  div.circularReference = div;
  div.lotsOfData = new Array(10000).join("*");
};
/* 如果该属性没有显示移除或者设为 null，引用计数式垃圾收集器将总是且至少有一个引用，并将一直保持在内存里的 DOM 元素，即使其从 DOM 树中删去了。如果这个 DOM 元素拥有大量的数据 (如上的 `lotsOfData` 属性)，而这个数据占用的内存将永远不会被释放
*/
```


-   在局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。但是全局变量什么时候需要自动释放内存空间则很难判断，因此在我们的开发中，需要尽量避免使用全局变量，以确保性能问题。

#### 标记-清除

当程序执行流入到一个函数中时，会创建该函数的执行上下文，执行上下文中的变量都会被标记为 **进入环境**，从逻辑上讲，永远不能释放 **进入执行环境** 变量所占用的内存。因为只要执行流进入相应的执行上下文，就可能会用到这些变量
-   垃圾收集器在运行的时候会给存储在内存的中的 **所有变量都加上标记**
-   去掉 **执行上下文中的变量** 以及 **被环境中的变量引用的变量** 的标记
-   那些 **还存在标记的变量将被视为准备删除的变量**
-   最后垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间
![[tag-clear.webp]]

-   优点：简单
-   缺点：内存碎片化、分配速度慢

#### 标记-整理
标记结束后，标记整理算法会将活着的对象(即不需要清理的对象)向内存的一端移动，最后清理掉边界的内存
虽然算法的名字上只有标记和整理，但这个算法通常有 3 个阶段，即**标记**、**整理**与**清除**。
- 首先，在标记阶段，垃圾回收器会从全局对象（根）开始，一层一层往下查询，直到标记完所有活跃的对象，那么剩下的未被标记的对象就是不可达的了
- 然后是整理阶段（碎片整理），垃圾回收器会将活跃的（被标记了的）对象往内存空间的一端移动，这个过程可能会改变内存中的对象的内存地址
- 最后来到清除阶段，垃圾回收器会将边界后面（也就是最后一个活跃的对象后面）的对象清除，并释放它们占用的内存空间

#### V8垃圾回收

##### 思路
- 第一步 通过 `GC Root` 标记活动对象与非活动对象（将一些 `GC Root`（包括`Window对象`、`文档DOM树`）作为初始存活的对象的集合，从`GC Root`出发，遍历所有的对象。遍历到的对象我们认为它是`可访问的`，即活动对象；反之是非活动对象）
- 第二步 回收非活动对象的内存
- 第三步 内存整理（回收内存后，内存中出现大量不连续的空间，如果不清理，那么当我们需要分配大量连续内存时，就会内存不足）
##### 概念
新生代：通常只支持 `1～8M` 的容量
老生代：支持的容量很大。
副垃圾回收器：负责新生代的垃圾回收。大多数小的对象都会被分配到新生代，垃圾回收比较频繁。
主垃圾回收器：负责老生代的垃圾回收。

##### 副垃圾回收器
分区：使用 Scavenge 算法，把新生代空间对半划分为两个区域，一半是对象区 ，一半是空闲区
![[GCspace.png]]
清理：新加入的对象都会被存放到对象区域，**当对象区域快被写满时，执行一次垃圾回收**。
首先将对象区中的垃圾做标记。标记完成后进入清理阶段，把这些存活的对象复制到空闲区中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就完成了内存整理操作，复制后空闲区域就没有内存碎片了。
![[zclean.png]]