
JavaScript 是在创建变量（对象，字符串等）时自动进行了分配内存，并且在不使用它们时“自动”释放。释放的过程称为垃圾回收
# 内存生命周期
1. 分配你所需要的内存
2.  使用分配到的内存（读、写）
3.  不需要时将其释放/归还

## JS 环境中分配的内存生命周期：
1.  内存分配（内存由操作系统分配，允许您的程序使用它）：当我们申明变量、函数、对象的时候，系统会自动为他们分配内存
2.  内存使用（这是程序实际使用先前分配的内存的时间。当您在代码中使用分配的变量时，就会发生读取和写入操作）：即读写内存，也就是使用变量、函数等
3.  内存回收（释放不需要的全部内存的时候了，以便它可以再次释放并可用）：使用完毕，由垃圾回收机制自动回收不再使用的内存
### JavaScript 的内存分配
#### 值的初始化
JavaScript 在定义变量时就完成了内存分配
``` javascript
// 给数值变量分配内存
let number = 123;
// 给字符串分配内存
let string = "string";
// 给对象及其包含的值分配内存
let obj = {
  obj1: 1,
  obj2: 'string'
}; 
// 给数组及其包含的值分配内存（对象）
let arr = [123, "string"];
// 给函数（对象）分配内存
function fn(param){
  return param;
} 
// 函数表达式也能分配内存
someElement.addEventListener(
  'click',
  function () {
    someElement.style.backgroundColor = 'blue';
  },
  false
);
```

####  通过函数调用分配内存
函数调用结果分配对象内存
``` javascript
var date = new Date(); // 分配一个 Date 对象
var ele = document.createElement('div'); // 分配一个 DOM 元素
```
#### 分配新变量或新对象

``` javascript
var s = "azerty";
var s2 = s.substr(0, 3); // s2 是一个新的字符串
// 因为字符串是不变量，
// JavaScript 可能决定不分配内存，
// 只是存储了 [0-3] 的范围。
var a = ["ouais ouais", "nan nan"];
var a2 = ["generation", "nan nan"];
var a3 = a.concat(a2);
// 新数组有四个元素，是 a 连接 a2 的结果
```

### 内存的使用
实际上是对分配内存进行读取与写入的操作。读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数
``` javascript
let a = 123
console.log(a) // 内存的读取
```
### 内存回收

####  垃圾收集
由于无法确定某些内存是否“不再需要”，因此垃圾收集对一般问题的解决方案实施了限制

####  引用计数
垃圾回收算法主要依赖于引用的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个 Javascript 对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）

这是最初级的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收

当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是 `1`，如果这个值再被赋值给另一个变量，则引用次数加 `1`。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减 `1`。当这个引用次数变成 `0` 时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为 `0` 的值所占的内存。

```javascript 
var o = {
  a: {
    b:2
  }
};
// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量 o
// 很显然，没有一个可以被垃圾收集


var o2 = o; // o2 变量是第二个对“这个对象”的引用

o = 1;      // 现在，“这个对象”只有一个 o2 变量的引用了，“这个对象”的原始引用 o 已经没有

var oa = o2.a; // 引用“这个对象”的 a 属性
               // 现在，“这个对象”有两个引用了，一个是 o2，一个是 oa

o2 = "yo"; // 虽然最初的对象现在已经是零引用了，可以被垃圾回收了
           // 但是它的属性 a 的对象还在被 oa 引用，所以还不能回收

oa = null; // a 属性的那个对象现在也是零引用了
           // 它可以被垃圾回收了

```
无法处理循环引用的事例。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。
``` javascript
function f(){
  var o = {};
  var o2 = {};
  o.a = o2; // o 引用 o2
  o2.a = o; // o2 引用 o

  return "azerty";
}

f();

var div;
window.onload = function(){
  div = document.getElementById("myDivElement");
  div.circularReference = div;
  div.lotsOfData = new Array(10000).join("*");
};
/* 如果该属性没有显示移除或者设为 null，引用计数式垃圾收集器将总是且至少有一个引用，并将一直保持在内存里的 DOM 元素，即使其从 DOM 树中删去了。如果这个 DOM 元素拥有大量的数据 (如上的 `lotsOfData` 属性)，而这个数据占用的内存将永远不会被释放
*/
```


-   在局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。但是全局变量什么时候需要自动释放内存空间则很难判断，因此在我们的开发中，需要尽量避免使用全局变量，以确保性能问题。

#### 标记-清除

当程序执行流入到一个函数中时，会创建该函数的执行上下文，执行上下文中的变量都会被标记为 **进入环境**，从逻辑上讲，永远不能释放 **进入执行环境** 变量所占用的内存。因为只要执行流进入相应的执行上下文，就可能会用到这些变量
-   垃圾收集器在运行的时候会给存储在内存的中的 **所有变量都加上标记**
-   去掉 **执行上下文中的变量** 以及 **被环境中的变量引用的变量** 的标记
-   那些 **还存在标记的变量将被视为准备删除的变量**
-   最后垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间
![[tag-clear.webp]]

根节点：
1.  全局对象
2.  本地函数的局部变量和参数
3.  当前嵌套调用链上的其他函数的变量和参数

-   优点：简单
-   缺点：内存碎片化、分配速度慢

#### 标记-整理
标记结束后，标记整理算法会将活着的对象(即不需要清理的对象)向内存的一端移动，最后清理掉边界的内存
虽然算法的名字上只有标记和整理，但这个算法通常有 3 个阶段，即**标记**、**整理**与**清除**。
- 首先，在标记阶段，垃圾回收器会从全局对象（根）开始，一层一层往下查询，直到标记完所有活跃的对象，那么剩下的未被标记的对象就是不可达的了
- 然后是整理阶段（碎片整理），垃圾回收器会将活跃的（被标记了的）对象往内存空间的一端移动，这个过程可能会改变内存中的对象的内存地址
- 最后来到清除阶段，垃圾回收器会将边界后面（也就是最后一个活跃的对象后面）的对象清除，并释放它们占用的内存空间

#### V8垃圾回收

##### 思路
- 第一步 通过 `GC Root` 标记活动对象与非活动对象（将一些 `GC Root`（包括`Window对象`、`文档DOM树`）作为初始存活的对象的集合，从`GC Root`出发，遍历所有的对象。遍历到的对象我们认为它是`可访问的`，即活动对象；反之是非活动对象）
- 第二步 回收非活动对象的内存
- 第三步 内存整理（回收内存后，内存中出现大量不连续的空间，如果不清理，那么当我们需要分配大量连续内存时，就会内存不足）
##### 概念
`新生代`：通常只支持 `1～8M` 的容量,大多数的对象开始都会被分配在这里，这个区域相对较小但是垃圾回收特别频繁，该区域被分为两半，一半用来分配内存，另一半用于在垃圾回收时将需要保留的对象复制过来;
`老生代`：支持的容量很大。新生代中的对象在存活一段时间后就会被转移到老生代内存区，相对于新生代该内存区域的垃圾回收频率较低。老生代又分为`老生代指针区`和`老生代数据区`，前者包含大多数可能存在指向其他对象的指针的对象，后者只保存原始数据对象，这些对象没有指向其他对象的指针;
`大对象区(large_object_space)`：存放体积超越其他区域大小的对象，每个对象都会有自己的内存，垃圾回收不会移动大对象区
`代码区(code_space)`：代码对象，会被分配在这里，唯一拥有执行权限的内存区域。
`map区(map_space)`：存放Cell和Map，每个区域都是存放相同大小的元素，结构简单
`副垃圾回收器`：负责新生代的垃圾回收。大多数小的对象都会被分配到新生代，垃圾回收比较频繁。
`主垃圾回收器`：负责老生代的垃圾回收。
![[gc_space.png]]
##### 新生代  副垃圾回收器
新生代内存是由两个`semispace(半空间)`构成的，内存最大值在`64`位系统和`32`位系统上分别为`32MB`和`16MB`，在新生代的垃圾回收过程中主要采用了`Scavenge`算法；在新生代内存中，大部分对象的生命周期较短，在时间效率上表现可观，所以还是比较适合这种算法
>Scavenge是一个牺牲空间换时间的算法，采用了`Cheney`算法，它将新生代内存一分为二，每一个部分的空间称为`semispace`，也就是我们在下图中的young Space中划分的两个区域，其中处于激活状态的区域我们称为`From`空间（对象区），未激活的区域我们称为`To`空间（空闲区）。这两个空间中，始终只有一个处于使用状态，另一个处于闲置状态。我们的程序中声明的对象首先会被分配到`From`空间，当进行垃圾回收时，如果`From`空间中尚有存活对象，则会被复制到`To`空间进行保存，非存活的对象会被自动回收。当复制完成后，`From`空间和`To`空间完成一次角色互换，`To`空间会变为新的`From`空间，原来的`From`空间则变为`To`空间

![[GCspace.png]]
清理：新加入的对象都会被存放到对象区域，**当对象区域快被写满时，执行一次垃圾回收**。
首先将对象区中的垃圾做标记。标记完成后进入清理阶段，把这些存活的对象复制到空闲区中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就完成了内存整理操作，复制后空闲区域就没有内存碎片了。
![[zclean.png]]
将存活对象在`对象区`空间和`空闲`空间之间进行复制，同时完成两个空间之间的角色互换，因此该算法的缺点也比较明显，浪费了一半的内存用于复制

##### 对象晋升
当一个对象在经过多次复制之后依旧存活，那么它会被认为是一个生命周期较长的对象，在下一次进行垃圾回收时，该对象会被直接转移到老生代中，这种对象从新生代转移到老生代的过程我们称之为`晋升`
条件：
-   对象是否经历过一次`Scavenge`算法
>当进行垃圾回收时，在将对象从`From`空间复制到`To`空间之前，会先检查该对象的内存地址来判断是否已经经历过一次`Scavenge`算法，如果地址已经发生变动则会将该对象转移到老生代中，不会再被复制到`To`空间
-   `To`空间的内存占比是否已经超过`25%`
>`To`空间在经历过一次`Scavenge`算法后会和`From`空间完成角色互换，会变为`From`空间，后续的内存分配都是在`From`空间中进行的，如果内存使用过高甚至溢出，则会影响后续对象的分配，因此超过这个限制之后对象会被直接转移到老生代来进行管理

##### 老生代
来源：
-   新生代中晋升的对象
-   一些大的对象会直接被分配到老生代里

算法：`Mark-Sweep(标记清除)`和`Mark-Compact(标记整理)`算法

###### 全停顿
由于JS的单线程机制，垃圾回收的过程会阻碍主线程同步任务的执行，待执行完垃圾回收后才会再次恢复执行主任务的逻辑，这种行为被称为`全停顿(stop-the-world)`。在标记阶段同样会阻碍主线程的执行，一般来说，老生代会保存大量存活的对象，如果在标记阶段将整个堆内存遍历一遍，那么势必会造成严重的卡顿
![[old-space-bad.png]]


######  增量回收
将原本需要一次性遍历堆内存的操作改为增量标记的方式，先标记堆内存中的一部分对象，然后暂停，将执行权重新交给JS主线程，待主线程任务执行完毕后再从原来暂停标记的地方继续标记，直到标记完整个堆内存
![[inc-gc.png]]

-   垃圾回收可以被暂停和重启，暂停时需要保存当时的标记结果，等下一次垃圾回收继续启动。
-   在暂停期间，被标记好的垃圾数据如果被 JavaScript 修改了，那么垃圾回收器需要能够正确地处理

在没有采用增量回收以前，`V8` 使用黑色和白色来标记数据。在执行一次完整的垃圾回收之前，垃圾回收器会将所有的数据设置为白色，用来表示这些数据还没有被标记，然后垃圾回收器在会从 `GC Roots` 出发，将所有能访问到的数据标记为黑色。遍历结束之后，被标记为黑色的数据就是活动数据，那些白色数据就是垃圾数据。

如果内存中的数据只有两种状态，非黑即白。那么当你暂停了当前的垃圾回收器之后，恢复时垃圾回收器就不知道从哪个位置继续开始执行了
###### 三色标记法
垃圾回收器依据当前内存中有没有灰色节点，来判断整个标记是否完成。如果没有灰色节点了，就可以进行清理工作了。如果还有灰色标记，当下次恢复垃圾回收器时，便从灰色的节点开始继续执行。
-   黑色表示这个节点被 `GC Root` 引用到了，而且该节点的子节点都已经标记完成了。
-   灰色表示这个节点被 `GC Root` 引用到，但子节点还没被垃圾回收器标记处理，也表明目前正在处理这个节点；
-   白色表示这个节点没有被访问到，如果在本轮遍历结束时还是白色，那么这块数据就会被收回
- 当发生了黑色节点引用了白色节点，写屏障机制会**强制将被引用的白色节点变成灰色**。这个方法也被称为**强三色不变性**，它保证了垃圾回收器能够正确地回收数据，因为在标记结束时的所有白色对象，对于垃圾回收器来说，都是可以清理的

